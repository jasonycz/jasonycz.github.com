---
layout:     post
title:      "2种分页解决思路"
subtitle:   ""
date:       2020-06-07 10:03:30
author:     "Jasonycz"
header-img: ""
tags:
    - 技术
---

# 2 种分页解决思路
在展现数据量比较大，常常需要进行分页处理来提高用户体验。

常见的分页主要有:
- 基于偏移量分页（Offset-based）
- 基于游标分页（Cursor-based）

接下来将分析他们的原理，优劣，适用场景。

# 基于偏移量分页（Offset-based）
> 原理

基于偏移量分页的查询语句常常如下:
```
SELECT * FROM `tableName` LIMIT pageSize OFFSET (pageNum-1)*pageSize;
```
即根据条件查出符合条件的所有记录数，然后取偏移量为 `(pageNum-1)*pageSize` 的最多 `pageSize` 条数据。

- `pageNum`:页码，表示从哪里读取数据
- `pageSize`:每页最多数据量


> 优劣

- 优势
  - 非常容易理解，实现简单
  - 可以选定页码（前一页，后一页，最后一页等），用户体验好
- 劣势
  - 大规模数据，效率低。因为数据库需要先查询出来符合条件的，然后再选取 `offset` 偏移量的数据 `pageSize` 个（需要 `count` 和 `skip`）
  - **数据不置信**。因为如果有插入和删除数据，那么某条数据可能出现两次或者翻页越界
  - 分布式系统中实现起来麻烦。因为可能需要扫描不同的数据碎片

> 适用场景

- 小数据量
- 允许出现数据误差

# 基于游标分页（Cursor-based）
> 原理

客户端请求服务端后，服务端除了返回具体数据外还返回 `cursor`游标作为下次客户端请求读取数据的开始位置。

基于游标分页的查询语句样例（此时 id 作为游标）:
```
SELECT * FROM `tableName` WHERE "id" > cursor LIMIT pageSize;
```

- `cursor`:要读取数据的开始位置，放在`where`条件中，同时会和索引字段对应上，上述样例对应的就是 `id` 主键
- `pageSize`:每页最多数据量


> 优劣

- 优势
  - 性能好。因为 `cursor` 字段通常都是索引，查询起来效率高
  - 一致性高。因为查询条件是基于 `cursor`，`cursor`不会随着添加或者删除数据影响
- 劣势
  - 无法跳转到指定的页面
  - 结果必须基于一个唯一且顺序的字段，不可以让添加记录到任意位置，这里的唯一且顺序的字段比如 `id`

常见的 `cursor` 字段的选择
- id, 顺序的主键
- 时间戳
- 加密字符串。它们看起来像随机字符串，但实际上通常是 `cursor` 里面加了额外信息

> 适用场景

- 高吞吐
- 数据一致性要求高
- 分页逐一加减，而不是跳跃场景，比如页面上拉（页面+1）

# 翻页最佳实践
- 设定 `pageSize` 限制
- 针对大数据集，尽量不要适用 `Offset-based` 分页
- 分页的默认排序，新的数据先返回，旧的数据放后面
- 不要在 `cursor` 中含有敏感信息
- 分页的时候，最好把下一页的链接一起返回，这样翻页策略变更，客户端基本无感知